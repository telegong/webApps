<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Markdown Read & PopUp Edit, OverWrite</title>

  <link id="hljs-theme" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/lisp.min.js"></script>

<style>
/* (ìƒëµ: ê¸°ì¡´ ìŠ¤íƒ€ì¼ ê·¸ëŒ€ë¡œ) */
html, body { height: 100%; margin: 0; display: flex; flex-direction: column; }
button.active { filter: invert(100%); }
.topbar { flex: 0 0 auto; display: flex; gap: 8px; padding: 8px 12px; }
.preview { flex: 1 1 auto; overflow-y: auto; padding: 16px; background: var(--preview-bg, #fff); color: var(--preview-fg, #000); transition: padding-bottom 0.2s ease; font-weight: 550; line-height: 1.5; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
body.dark { background: #121212; color: #eee; }
body.dark .preview { background: #1e1e1e; color: var(--preview-fg, #fff); border-color: #444; }
.editor { position: fixed; left: 0; right: 0; bottom: 0; max-height: 60vh; background: var(--panel-bg, #111); border-top: 1px solid #333; box-shadow: 0 -8px 24px rgba(0,0,0,0.25); display: grid; grid-template-rows: 1fr auto; transition: transform 220ms ease, opacity 220ms ease; }
.editor.collapsed { transform: translateY(100%); opacity: 0; pointer-events: none; }
.editor textarea { width: 100%; height: 300px; resize: vertical; padding: 12px; padding-bottom: 200px; box-sizing: border-box; font-size: 16px; font-weight: 600; line-height: 1.5; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
@media print { html, body { height: auto !important; display: block !important; overflow: visible !important; } .topbar, .editor { display: none !important; } .preview { height: auto !important; overflow: visible !important; padding: 0 !important; } }
</style>
</head>

<body>
  <header class="topbar">
    <button onclick="activateButtonAsync(this, pickFile)">ğŸ“ ì—´ê¸°</button>
    <button id="toggleEditor" onclick="activateButton(this, toggleEditor)">ğŸ“ í¸ì§‘ê¸°</button>
    <button onclick="activateButton(this, openEditorPopup)">ğŸªŸ íŒì—… í¸ì§‘ê¸°</button>
    <button onclick="activateButton(this, openMonacoPopup)">ğŸªŸ ëª¨ë‚˜ì½” í¸ì§‘ê¸°</button>
    <button onclick="activateButton(this, toggleTheme)">ğŸŒ™/â˜€ï¸ í…Œë§ˆ ì „í™˜</button>
    <button onclick="activateButtonAsync(this, saveText)">ğŸ’¾ ì €ì¥</button>
    <button onclick="activateButtonAsync(this, saveAs)">ğŸ“„ ë‹¤ë¥¸ ì´ë¦„ìœ¼ë¡œ ì €ì¥</button>
    <button onclick="window.print()">ğŸ–¨ï¸ ì¸ì‡„</button>
  </header>
  <div id="fileStatus" style="padding: 4px 12px; font-size: 14px; color: #666;">ğŸ“„ íŒŒì¼ ì—†ìŒ</div>

  <main id="preview" class="preview">
    <p>ì—¬ê¸°ì— ë¯¸ë¦¬ë³´ê¸°ê°€ í‘œì‹œë©ë‹ˆë‹¤</p>
  </main>

  <section id="editorPanel" class="editor collapsed">
    <textarea id="markdown" placeholder="# ì œëª©ìœ¼ë¡œ ì‹œì‘í•´ë³´ì„¸ìš”">
ë“œë˜ê·¸ ì•¤ ë“œë¡­ê³¼ ë‹¤í¬ ëª¨ë“œ ì§€ì›!

```javascript
function greet() {
  console.log("Hello, Markdown!");
}
```
    </textarea>
    <div class="editor-actions">
      <button id="closeEditor">ì ‘ê¸°</button>
    </div>
  </section>

<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

<script>
// ì „ì—­ ìƒíƒœ
let popupWindows = [];
let suppressCloseOnUnload = false;
const editorState = { text: '', currentHandle: null };

const editor = document.getElementById('editorPanel');
const textarea = document.getElementById('markdown');
const preview = document.getElementById('preview');
let currentHandle = null;
let originalText = '';
let isModified = false;

function renderMarkdown(){
  preview.innerHTML = marked.parse(textarea.value);
  hljs.highlightAll();
}
renderMarkdown();

window.addEventListener('DOMContentLoaded', async () => {
  try {
    const params = new URLSearchParams(location.search);
    let filePath = params.get("file");
    if (!filePath) return;

    // URLì— ë”°ì˜´í‘œê°€ í¬í•¨ë¼ ì™”ìœ¼ë©´ ì œê±°
    filePath = decodeURIComponent(filePath).replace(/^"+|"+$/g, '');

    // ìƒëŒ€ê²½ë¡œë¡œ í•´ì„í•´ fetch ì‹œë„ (ì„œë²„ì—ì„œ ì œê³µë˜ëŠ” ê²½ìš°)
    const url = new URL(filePath, location.href).href;

    const response = await fetch(url);
    if (!response.ok) throw new Error(`Fetch failed: ${response.status}`);

    const text = await response.text();

    const textarea = document.getElementById('markdown');
    if (!textarea) throw new Error('textarea#markdown not found in DOM');

    textarea.value = text;
    renderMarkdown();
  } catch (err) {
    console.error('íŒŒì¼ ë¡œë“œ ì‹¤íŒ¨:', err);
    // ì‚¬ìš©ì ì•ˆë‚´ UI ì—…ë°ì´íŠ¸
    document.getElementById('fileStatus').textContent = 'íŒŒì¼ ë¡œë“œ ì‹¤íŒ¨ â€” ì½˜ì†” í™•ì¸';
  }
});

document.addEventListener('keydown', (e)=>{ if (e.key === 'Escape') editor.classList.add('collapsed'); });

function syncScroll(source, target){
  const ratio = source.scrollTop / (source.scrollHeight - source.clientHeight || 1);
  target.scrollTop = ratio * (target.scrollHeight - target.clientHeight || 0);
}
textarea.addEventListener('scroll', ()=> syncScroll(textarea, preview));

// textarea input -> broadcast to all popups
textarea.addEventListener('input', () => {
  editorState.text = textarea.value;
  isModified = textarea.value !== originalText;
  renderMarkdown();
  updateFileStatus();

  popupWindows = popupWindows.filter(p => p && !p.closed);
  popupWindows.forEach(p => {
    try { p.postMessage({ type: 'sync', text: textarea.value }, '*'); } catch (err) {}
  });
});

// ì •ë¦¬ íƒ€ì´ë¨¸(ì•ˆì „ë§)
setInterval(() => { popupWindows = popupWindows.filter(p => p && !p.closed); }, 2000);

// ë²„íŠ¼ helper
function activateButton(btn, action){
  btn.classList.add('active');
  setTimeout(()=>{ action(); btn.classList.remove('active'); }, 100);
}
async function activateButtonAsync(btn, asyncAction){
  btn.classList.add('active');
  try { await asyncAction(); } finally { btn.classList.remove('active'); }
}

// íŒŒì¼ ì„ íƒ
async function pickFile(){
  suppressCloseOnUnload = true;
  try {
    const [handle] = await window.showOpenFilePicker({
      types: [{ description: 'Markdown', accept: { 'text/markdown': ['.md', '.md.txt'], 'text/plain': ['.txt'] } }]
    });
    await openFile(handle);
  } finally {
    setTimeout(()=> suppressCloseOnUnload = false, 150);
  }
}

// ë“œë˜ê·¸ ì•¤ ë“œë¡­
preview.addEventListener('dragover', (e) => e.preventDefault());
preview.addEventListener('drop', async (e) => {
  e.preventDefault();
  suppressCloseOnUnload = true;
  try {
    const item = e.dataTransfer.items[0];
    if (item && item.kind === 'file') {
      const handle = await item.getAsFileSystemHandle();
      if (handle && handle.kind === 'file') await openFile(handle);
    }
  } finally {
    setTimeout(()=> suppressCloseOnUnload = false, 150);
  }
});

// íŒì—… ë‹«ê¸° í•¨ìˆ˜
function closeAllPopups() {
  popupWindows.forEach(p => { try { if (p && !p.closed) p.close(); } catch(e){} });
  popupWindows = [];
}

// beforeunload: ê¸°ë³¸ì ìœ¼ë¡œ ìƒˆë¡œê³ ì¹¨/íƒ­ë‹«ê¸° ë•Œ íŒì—… ë‹«ìŒ
window.addEventListener('beforeunload', (e) => {
  if (!suppressCloseOnUnload) closeAllPopups();
  // ì €ì¥ í™•ì¸ì„ ë„¤ì´í‹°ë¸Œë¡œ ë„ìš°ë ¤ë©´ ì•„ë˜ì²˜ëŸ¼ ë©”ì‹œì§€ ì„¸íŒ… ê°€ëŠ¥(ë¸Œë¼ìš°ì € ì§€ì› ì œí•œ)
  if (isModified) {
    const msg = "ì €ì¥í•˜ì§€ ì•Šì€ ë³€ê²½ì‚¬í•­ì´ ìˆìŠµë‹ˆë‹¤. ê³„ì†í•˜ë©´ ë³€ê²½ì‚¬í•­ì´ ì†ì‹¤ë©ë‹ˆë‹¤.";
    e.returnValue = msg;
    return msg;
  }
});

// openFile (íŒŒì¼ ì—´ê¸°)
async function openFile(handle){
  // ìƒˆ íŒŒì¼ ì—´ ë•Œ ê¸°ì¡´ íŒì—… ë‹«ê¸°(ì„ íƒì )
  //closeAllPopups();
  /* const shouldClose = confirm("íŒŒì¼ì„ ì—´ë©´ í˜„ì¬ ì—´ë¦° íŒì—…ë“¤ì„ ë‹«ìŠµë‹ˆë‹¤. [ì·¨ì†Œ]íŒì—…ìœ ì§€");
  if (shouldClose) closeAllPopups();
  */

  const file = await handle.getFile();
  const text = await file.text();
  editorState.text = text;
  editorState.currentHandle = handle;

  textarea.value = text;
  originalText = text;
  isModified = false;
  currentHandle = handle;
  renderMarkdown();
  updateFileStatus();

  // í•„ìš”ì‹œ íŒì—…ë“¤ì´ ìˆë‹¤ë©´ ë™ê¸°í™” (ì—¬ê¸°ì„  ì´ë¯¸ closeAllPopups í˜¸ì¶œí–ˆìœ¼ë¯€ë¡œ ë°°ì—´ ë¹„ì–´ìˆìŒ)
  popupWindows = popupWindows.filter(p => p && !p.closed);
  popupWindows.forEach(p => {
    try { p.postMessage({ type: 'sync', text }, '*'); } catch (err) {}
  });
}

// ì €ì¥, ë‹¤ë¥¸ ì´ë¦„ìœ¼ë¡œ ì €ì¥ (ê¸°ì¡´ ì½”ë“œ ìœ ì§€)
async function saveText(){
  const text = textarea.value;
  if (!currentHandle) {
    const options = { types: [{ description: 'Markdown Files', accept: { 'text/markdown': ['.md'], 'text/plain': ['.txt'] } }]};
    try { currentHandle = await window.showSaveFilePicker(options); } catch(e){ console.warn("ì €ì¥ ì·¨ì†Œ", e); return; }
  }
  try {
    const writable = await currentHandle.createWritable();
    await writable.write(text);
    await writable.close();
    originalText = text; isModified = false; updateFileStatus();
    alert("ì €ì¥ ì™„ë£Œ!");
  } catch (err) { console.error("ì €ì¥ ì‹¤íŒ¨", err); alert("ì €ì¥ ì¤‘ ì˜¤ë¥˜"); }
}
async function saveAs(){
  const text = textarea.value;
  const options = { suggestedName: 'document.md', types:[{ description:'Markdown Files', accept:{ 'text/markdown':['.md'], 'text/plain':['.txt'] } }]};
  try {
    const handle = await window.showSaveFilePicker(options);
    const writable = await handle.createWritable();
    await writable.write(text);
    await writable.close();
    currentHandle = handle; originalText = text; isModified = false; updateFileStatus();
    alert("ë‹¤ë¥¸ ì´ë¦„ìœ¼ë¡œ ì €ì¥ ì™„ë£Œ!");
  } catch (err) { if (err.name !== 'AbortError') { console.error("ë‹¤ë¥¸ ì´ë¦„ ì €ì¥ ì‹¤íŒ¨", err); alert("ì €ì¥ ì¤‘ ì˜¤ë¥˜"); } }
}

async function updateFileStatus(){
  let name = 'íŒŒì¼ ì—†ìŒ';
  if (currentHandle && currentHandle.name) name = currentHandle.name;
  else if (currentHandle) { const file = await currentHandle.getFile(); name = file.name; }
  const status = isModified ? 'ğŸŸ¡ ìˆ˜ì •ë¨' : 'ğŸŸ¢ ì €ì¥ë¨';
  document.getElementById('fileStatus').textContent = `ğŸ“„ ${name} â€” ${status}`;
}

function toggleTheme(){
  document.body.classList.toggle('dark');
  const link = document.querySelector('#hljs-theme');
  if (document.body.classList.contains('dark')) link.href = "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css";
  else link.href = "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css";
}

function updatePreviewPadding(){ if (editor.classList.contains('collapsed')) preview.style.paddingBottom = '0px'; else preview.style.paddingBottom = editor.offsetHeight + 'px'; }
function toggleEditor(){ editor.classList.toggle('collapsed'); updatePreviewPadding(); }
document.getElementById('closeEditor').addEventListener('click', () => { editor.classList.add('collapsed'); updatePreviewPadding(); });
window.addEventListener('resize', updatePreviewPadding);
const ro = new ResizeObserver(() => updatePreviewPadding()); ro.observe(editor);

// íŒì—… ì—´ê¸° (ë³„ë„ íŒŒì¼ popup.html ì‚¬ìš©)
function openEditorPopup() {
  // open with unique name if you want multiple instances, or fixed name to reuse window
  const popup = window.open('popup.html', `editorPopup-${Date.now()}`, 'width=640,height=480,resizable=yes');
  popupWindows.push(popup);
}

// ë©”ì¸: ë©”ì‹œì§€ ìˆ˜ì‹  (íŒì—…ì˜ request-sync ì¬ë“±ë¡, íŒì—… ì—…ë°ì´íŠ¸ ë¸Œë¡œë“œìºìŠ¤íŠ¸)
window.addEventListener('message', (e) => {
  if (!e.data || !e.data.type) return;

  if (e.data.type === 'request-sync') {
    try {
      const src = e.source;
      if (src && !popupWindows.includes(src)) popupWindows.push(src);
      src.postMessage({ type: 'sync', text: textarea.value }, '*');
    } catch (err) { console.warn('request-sync ì²˜ë¦¬ ì¤‘ ì—ëŸ¬', err); }
    return;
  }

  if (e.data.type === 'update') {
    if (typeof e.data.text === 'string') {
      textarea.value = e.data.text;
      editorState.text = e.data.text;
      renderMarkdown();
      updateFileStatus();
    }
    popupWindows = popupWindows.filter(p => p && !p.closed);
    popupWindows.forEach(p => {
      try { if (p !== e.source && !p.closed) p.postMessage({ type: 'sync', text: e.data.text }, '*'); } catch (err) {}
    });
  }
});

// ëª¨ë‚˜ì½” íŒì—… ì—´ê¸° (ë³„ë„ íŒŒì¼ monaco.html)
function openMonacoPopup() {
  const popup = window.open('monaco.html', `monacoEditor-${Date.now()}`, 'width=800,height=600,resizable=yes');
  popupWindows.push(popup);
}
</script>
</body>

</html>

