<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Markdown Read & PopUp Edit, OverWrite</title>

  <link id="hljs-theme" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/lisp.min.js"></script>

<style>
/* (생략: 기존 스타일 그대로) */
html, body { height: 100%; margin: 0; display: flex; flex-direction: column; }
button.active { filter: invert(100%); }
.topbar { flex: 0 0 auto; display: flex; gap: 8px; padding: 8px 12px; }
.preview { flex: 1 1 auto; overflow-y: auto; padding: 16px; background: var(--preview-bg, #fff); color: var(--preview-fg, #000); transition: padding-bottom 0.2s ease; font-weight: 550; line-height: 1.5; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
body.dark { background: #121212; color: #eee; }
body.dark .preview { background: #1e1e1e; color: var(--preview-fg, #fff); border-color: #444; }
.editor { position: fixed; left: 0; right: 0; bottom: 0; max-height: 60vh; background: var(--panel-bg, #111); border-top: 1px solid #333; box-shadow: 0 -8px 24px rgba(0,0,0,0.25); display: grid; grid-template-rows: 1fr auto; transition: transform 220ms ease, opacity 220ms ease; }
.editor.collapsed { transform: translateY(100%); opacity: 0; pointer-events: none; }
.editor textarea { width: 100%; height: 300px; resize: vertical; padding: 12px; padding-bottom: 200px; box-sizing: border-box; font-size: 16px; font-weight: 600; line-height: 1.5; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
@media print { html, body { height: auto !important; display: block !important; overflow: visible !important; } .topbar, .editor { display: none !important; } .preview { height: auto !important; overflow: visible !important; padding: 0 !important; } }
</style>
</head>

<body>
  <header class="topbar">
    <button onclick="activateButtonAsync(this, pickFile)">📁 열기</button>
    <button id="toggleEditor" onclick="activateButton(this, toggleEditor)">📝 편집기</button>
    <button onclick="activateButton(this, openEditorPopup)">🪟 팝업 편집기</button>
    <button onclick="activateButton(this, openMonacoPopup)">🪟 모나코 편집기</button>
    <button onclick="activateButton(this, toggleTheme)">🌙/☀️ 테마 전환</button>
    <button onclick="activateButtonAsync(this, saveText)">💾 저장</button>
    <button onclick="activateButtonAsync(this, saveAs)">📄 다른 이름으로 저장</button>
    <button onclick="window.print()">🖨️ 인쇄</button>
  </header>
  <div id="fileStatus" style="padding: 4px 12px; font-size: 14px; color: #666;">📄 파일 없음</div>

  <main id="preview" class="preview">
    <p>여기에 미리보기가 표시됩니다</p>
  </main>

  <section id="editorPanel" class="editor collapsed">
    <textarea id="markdown" placeholder="# 제목으로 시작해보세요">
드래그 앤 드롭과 다크 모드 지원!

```javascript
function greet() {
  console.log("Hello, Markdown!");
}
```
    </textarea>
    <div class="editor-actions">
      <button id="closeEditor">접기</button>
    </div>
  </section>

<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

<script>
// 전역 상태
let popupWindows = [];
let suppressCloseOnUnload = false;
const editorState = { text: '', currentHandle: null };

const editor = document.getElementById('editorPanel');
const textarea = document.getElementById('markdown');
const preview = document.getElementById('preview');
let currentHandle = null;
let originalText = '';
let isModified = false;

function renderMarkdown(){
  preview.innerHTML = marked.parse(textarea.value);
  hljs.highlightAll();
}
renderMarkdown();

window.addEventListener('DOMContentLoaded', async () => {
  try {
    const params = new URLSearchParams(location.search);
    let filePath = params.get("file");
    if (!filePath) return;

    // URL에 따옴표가 포함돼 왔으면 제거
    filePath = decodeURIComponent(filePath).replace(/^"+|"+$/g, '');

    // 상대경로로 해석해 fetch 시도 (서버에서 제공되는 경우)
    const url = new URL(filePath, location.href).href;

    const response = await fetch(url);
    if (!response.ok) throw new Error(`Fetch failed: ${response.status}`);

    const text = await response.text();

    const textarea = document.getElementById('markdown');
    if (!textarea) throw new Error('textarea#markdown not found in DOM');

    textarea.value = text;
    renderMarkdown();
  } catch (err) {
    console.error('파일 로드 실패:', err);
    // 사용자 안내 UI 업데이트
    document.getElementById('fileStatus').textContent = '파일 로드 실패 — 콘솔 확인';
  }
});

document.addEventListener('keydown', (e)=>{ if (e.key === 'Escape') editor.classList.add('collapsed'); });

function syncScroll(source, target){
  const ratio = source.scrollTop / (source.scrollHeight - source.clientHeight || 1);
  target.scrollTop = ratio * (target.scrollHeight - target.clientHeight || 0);
}
textarea.addEventListener('scroll', ()=> syncScroll(textarea, preview));

// textarea input -> broadcast to all popups
textarea.addEventListener('input', () => {
  editorState.text = textarea.value;
  isModified = textarea.value !== originalText;
  renderMarkdown();
  updateFileStatus();

  popupWindows = popupWindows.filter(p => p && !p.closed);
  popupWindows.forEach(p => {
    try { p.postMessage({ type: 'sync', text: textarea.value }, '*'); } catch (err) {}
  });
});

// 정리 타이머(안전망)
setInterval(() => { popupWindows = popupWindows.filter(p => p && !p.closed); }, 2000);

// 버튼 helper
function activateButton(btn, action){
  btn.classList.add('active');
  setTimeout(()=>{ action(); btn.classList.remove('active'); }, 100);
}
async function activateButtonAsync(btn, asyncAction){
  btn.classList.add('active');
  try { await asyncAction(); } finally { btn.classList.remove('active'); }
}

// 파일 선택
async function pickFile(){
  suppressCloseOnUnload = true;
  try {
    const [handle] = await window.showOpenFilePicker({
      types: [{ description: 'Markdown', accept: { 'text/markdown': ['.md', '.md.txt'], 'text/plain': ['.txt'] } }]
    });
    await openFile(handle);
  } finally {
    setTimeout(()=> suppressCloseOnUnload = false, 150);
  }
}

// 드래그 앤 드롭
preview.addEventListener('dragover', (e) => e.preventDefault());
preview.addEventListener('drop', async (e) => {
  e.preventDefault();
  suppressCloseOnUnload = true;
  try {
    const item = e.dataTransfer.items[0];
    if (item && item.kind === 'file') {
      const handle = await item.getAsFileSystemHandle();
      if (handle && handle.kind === 'file') await openFile(handle);
    }
  } finally {
    setTimeout(()=> suppressCloseOnUnload = false, 150);
  }
});

// 팝업 닫기 함수
function closeAllPopups() {
  popupWindows.forEach(p => { try { if (p && !p.closed) p.close(); } catch(e){} });
  popupWindows = [];
}

// beforeunload: 기본적으로 새로고침/탭닫기 때 팝업 닫음
window.addEventListener('beforeunload', (e) => {
  if (!suppressCloseOnUnload) closeAllPopups();
  // 저장 확인을 네이티브로 띄우려면 아래처럼 메시지 세팅 가능(브라우저 지원 제한)
  if (isModified) {
    const msg = "저장하지 않은 변경사항이 있습니다. 계속하면 변경사항이 손실됩니다.";
    e.returnValue = msg;
    return msg;
  }
});

// openFile (파일 열기)
async function openFile(handle){
  // 새 파일 열 때 기존 팝업 닫기(선택적)
  //closeAllPopups();
  /* const shouldClose = confirm("파일을 열면 현재 열린 팝업들을 닫습니다. [취소]팝업유지");
  if (shouldClose) closeAllPopups();
  */

  const file = await handle.getFile();
  const text = await file.text();
  editorState.text = text;
  editorState.currentHandle = handle;

  textarea.value = text;
  originalText = text;
  isModified = false;
  currentHandle = handle;
  renderMarkdown();
  updateFileStatus();

  // 필요시 팝업들이 있다면 동기화 (여기선 이미 closeAllPopups 호출했으므로 배열 비어있음)
  popupWindows = popupWindows.filter(p => p && !p.closed);
  popupWindows.forEach(p => {
    try { p.postMessage({ type: 'sync', text }, '*'); } catch (err) {}
  });
}

// 저장, 다른 이름으로 저장 (기존 코드 유지)
async function saveText(){
  const text = textarea.value;
  if (!currentHandle) {
    const options = { types: [{ description: 'Markdown Files', accept: { 'text/markdown': ['.md'], 'text/plain': ['.txt'] } }]};
    try { currentHandle = await window.showSaveFilePicker(options); } catch(e){ console.warn("저장 취소", e); return; }
  }
  try {
    const writable = await currentHandle.createWritable();
    await writable.write(text);
    await writable.close();
    originalText = text; isModified = false; updateFileStatus();
    alert("저장 완료!");
  } catch (err) { console.error("저장 실패", err); alert("저장 중 오류"); }
}
async function saveAs(){
  const text = textarea.value;
  const options = { suggestedName: 'document.md', types:[{ description:'Markdown Files', accept:{ 'text/markdown':['.md'], 'text/plain':['.txt'] } }]};
  try {
    const handle = await window.showSaveFilePicker(options);
    const writable = await handle.createWritable();
    await writable.write(text);
    await writable.close();
    currentHandle = handle; originalText = text; isModified = false; updateFileStatus();
    alert("다른 이름으로 저장 완료!");
  } catch (err) { if (err.name !== 'AbortError') { console.error("다른 이름 저장 실패", err); alert("저장 중 오류"); } }
}

async function updateFileStatus(){
  let name = '파일 없음';
  if (currentHandle && currentHandle.name) name = currentHandle.name;
  else if (currentHandle) { const file = await currentHandle.getFile(); name = file.name; }
  const status = isModified ? '🟡 수정됨' : '🟢 저장됨';
  document.getElementById('fileStatus').textContent = `📄 ${name} — ${status}`;
}

function toggleTheme(){
  document.body.classList.toggle('dark');
  const link = document.querySelector('#hljs-theme');
  if (document.body.classList.contains('dark')) link.href = "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css";
  else link.href = "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css";
}

function updatePreviewPadding(){ if (editor.classList.contains('collapsed')) preview.style.paddingBottom = '0px'; else preview.style.paddingBottom = editor.offsetHeight + 'px'; }
function toggleEditor(){ editor.classList.toggle('collapsed'); updatePreviewPadding(); }
document.getElementById('closeEditor').addEventListener('click', () => { editor.classList.add('collapsed'); updatePreviewPadding(); });
window.addEventListener('resize', updatePreviewPadding);
const ro = new ResizeObserver(() => updatePreviewPadding()); ro.observe(editor);

// 팝업 열기 (별도 파일 popup.html 사용)
function openEditorPopup() {
  // open with unique name if you want multiple instances, or fixed name to reuse window
  const popup = window.open('popup.html', `editorPopup-${Date.now()}`, 'width=640,height=480,resizable=yes');
  popupWindows.push(popup);
}

// 메인: 메시지 수신 (팝업의 request-sync 재등록, 팝업 업데이트 브로드캐스트)
window.addEventListener('message', (e) => {
  if (!e.data || !e.data.type) return;

  if (e.data.type === 'request-sync') {
    try {
      const src = e.source;
      if (src && !popupWindows.includes(src)) popupWindows.push(src);
      src.postMessage({ type: 'sync', text: textarea.value }, '*');
    } catch (err) { console.warn('request-sync 처리 중 에러', err); }
    return;
  }

  if (e.data.type === 'update') {
    if (typeof e.data.text === 'string') {
      textarea.value = e.data.text;
      editorState.text = e.data.text;
      renderMarkdown();
      updateFileStatus();
    }
    popupWindows = popupWindows.filter(p => p && !p.closed);
    popupWindows.forEach(p => {
      try { if (p !== e.source && !p.closed) p.postMessage({ type: 'sync', text: e.data.text }, '*'); } catch (err) {}
    });
  }
});

// 모나코 팝업 열기 (별도 파일 monaco.html)
function openMonacoPopup() {
  const popup = window.open('monaco.html', `monacoEditor-${Date.now()}`, 'width=800,height=600,resizable=yes');
  popupWindows.push(popup);
}
</script>
</body>

</html>

